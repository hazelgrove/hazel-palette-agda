copied from all.agda so that i can ignore comments
-------------------------------------------------
open import structural-assumptions -- prove everything in here and then remove this file
open import structural -- this too, really
open import typed-expansion -- in complete-expansion
open import preservation -- in complete-preservation


deadline madness code snippets that i removed
---------------------------------------------
-- this goes in preservation.agda

-- replacing a variable in a term with contents of the appropriate type
 -- preserves type and contracts the context
  lem-subst : ∀{Δ Γ x τ1 d1 τ d2 } →
              Δ , Γ ,, (x , τ1) ⊢ d1 :: τ →
              Δ , Γ ⊢ d2 :: τ1 →
              Δ , Γ ⊢ [ d2 / x ] d1 :: τ
  lem-subst TAConst D2 = TAConst
  lem-subst {Γ = Γ} {x = x'} (TAVar {x = x} x₂) D2 with natEQ x x'
  lem-subst {Γ = Γ} {x = x} {τ1 = τ1} (TAVar x₃) D2 | Inl refl = {!!}
  lem-subst {Γ = Γ} {x = x} {τ1 = τ1} (TAVar {x = x'} x₃) D2 | Inr x₂ = {!x∈sing!}
  -- ... | qq = TAVar {!!}
  --   with Γ x
  -- lem-subst {x = x} (TAVar {x = x'} x₃) D2 | Some x₁ = {!!}
  --   with natEQ x' x
  -- lem-subst (TAVar xin) D2 | Some x₃ | Inl refl = {!!}
  -- lem-subst (TAVar refl) D2 | Some x₃ | Inr x₂ = {!!}
  -- lem-subst {x = x} (TAVar {x = x'} x₂) D2 | None with natEQ x' x
  --lem-subst {x = x} (TAVar x₃) D2 | None | Inl refl with natEQ x x
  -- lem-subst (TAVar refl) D2 | None | Inl refl | Inl refl = D2
  -- lem-subst (TAVar x₃) D2 | None | Inl refl | Inr x₁ = abort (somenotnone (! x₃))
  --lem-subst {x = x} (TAVar {x = x'} x₃) D2 | None | Inr x₂ with natEQ x x'
  -- lem-subst (TAVar x₄) D2 | None | Inr x₃ | Inl x₂ = abort ((flip x₃) x₂)
  -- lem-subst (TAVar x₄) D2 | None | Inr x₃ | Inr x₂ = abort (somenotnone (! x₄))
  lem-subst {Γ = Γ} {x = x} (TALam {x = x'} D1) D2 = {!!}
  lem-subst (TAAp D1 D2) D3 = TAAp (lem-subst D1 D3) (lem-subst D2 D3)
  lem-subst (TAEHole x₁ x₂) D2 = TAEHole x₁ {!!}
  lem-subst (TANEHole x₁ D1 x₂) D2 = TANEHole x₁ (lem-subst D1 D2) {!!}
  lem-subst (TACast D1 x₁) D2 = TACast (lem-subst D1 D2) x₁
  lem-subst (TAFailedCast D1 x₁ x₂ x₃) D2 = TAFailedCast (lem-subst D1 D2) x₁ x₂ x₃

-- this goes in typed expansion (or maybe a lemmas file)

  lem-weakenΔ1 : ∀{Δ1 Δ2 Γ d τ} → Δ1 ## Δ2 → Δ1 , Γ ⊢ d :: τ → (Δ1 ∪ Δ2) , Γ ⊢ d :: τ
  lem-weakenΔ1 d TAConst = TAConst
  lem-weakenΔ1 d (TAVar x₁) = TAVar x₁
  lem-weakenΔ1 d (TALam D) = TALam (lem-weakenΔ1 d D)
  lem-weakenΔ1 d (TAAp D D₁) = TAAp (lem-weakenΔ1 d D) (lem-weakenΔ1 d D₁)
  lem-weakenΔ1 d (TAEHole {Δ = Δ} x y) = TAEHole (x∈∪l Δ _ _ _ x) (subst-weaken {!!} y)
  lem-weakenΔ1 d (TANEHole {Δ = Δ} D x y) = TANEHole (x∈∪l Δ _ _ _ D) (lem-weakenΔ1 d x) (subst-weaken {!!} y)
  lem-weakenΔ1 d (TACast D x) = TACast (lem-weakenΔ1 d D) x
  lem-weakenΔ1 d (TAFailedCast x y z w) = TAFailedCast (lem-weakenΔ1 d x) y z w


-- complete expansion

-----
version of this lemma where the union in ,, is flipped; probably useless
-- ctx-top : {A : Set} → (Γ : A ctx) (n : Nat) (a : A) → (n , a) ∈ (Γ ,, (n , a))
-- ctx-top Γ n a with natEQ n n
-- ctx-top Γ n a | Inl refl = refl
-- ctx-top Γ n a | Inr x = abort (x refl)


ditto
-- gcomp-extend {Γ} {τ} {x} gc tc x₁ τ₁ x₂ with natEQ x₁ x
-- gcomp-extend gc tc x τ₁ x₃ | Inl refl with natEQ x x
-- gcomp-extend gc tc x τ refl | Inl refl | Inl refl = tc
-- gcomp-extend gc tc x τ₁ x₃ | Inl refl | Inr x₁ = gc x τ₁ x₃
-- gcomp-extend {Γ} {τ} {x} gc tc x₁ τ₁ x₃ | Inr x₂ with natEQ x x₁
-- gcomp-extend gc tc x τ₁ refl | Inr x₃ | Inl refl = tc
-- gcomp-extend gc tc x₁ τ₁ x₄ | Inr x₃ | Inr x₂ = gc x₁ τ₁ x₄

more removed code
--------------------------------------------------------
    -- weaken-subst-Γ {x = x} {Γ = Γ} {τ = τ1} apt (STAId x₁) = STAId (λ y τ2 x₂ → x∈∪l Γ (■ (x , τ1)) _ _ (x₁ y τ2 x₂))
    -- weaken-subst-Γ {x = x} {Γ = Γ} {τ = τ1} apt (STASubst {y = y} {τ = τ2} s x₁) with natEQ x y
    -- weaken-subst-Γ {x = x} {Γ = Γ} {τ = τ1} apt (STASubst {τ = τ2} s x₂) | Inl refl = STASubst {!!} (weaken-ta apt x₂)
    -- weaken-subst-Γ apt (STASubst s x₂) | Inr x₁ = STASubst {!!} (weaken-ta apt x₂)
    -- = STASubst {!!} (weaken-ta apt x₁)

      -- STASubst (weaken-subst-Γ {x = y} {Γ = Γ ,, (x , τ1)} {τ = τ2} {!!} {!!}) (weaken-ta apt x₁)


  -- this is false
  --
  -- apart-fresh : ∀{ x Γ Δ d τ} →
  --               x # Γ →
  --               Δ , Γ ⊢ d :: τ →
  --               fresh x d
  -- apart-fresh aprt TAConst = FConst
  -- apart-fresh {x = x} aprt (TAVar {x = y} x₂) with natEQ x y
  -- apart-fresh aprt (TAVar x₃) | Inl refl = abort (somenotnone (! x₃ · aprt))
  -- apart-fresh aprt (TAVar x₃) | Inr x₂ = FVar x₂
  -- apart-fresh {x = x} aprt (TALam {x = y} x₂ wt) with natEQ x y
  -- apart-fresh aprt (TALam x₃ wt) | Inl refl = {!!}
  -- apart-fresh aprt (TALam x₃ wt) | Inr x₂ = FLam x₂
  -- apart-fresh aprt (TAAp wt wt₁) = FAp (apart-fresh aprt wt) (apart-fresh aprt wt₁)
  -- apart-fresh aprt (TAEHole x₁ x₂) = FHole {!!}
  -- apart-fresh aprt (TANEHole x₁ wt x₂) = FNEHole {!!} (apart-fresh aprt wt)
  -- apart-fresh aprt (TACast wt x₁) = FCast (apart-fresh aprt wt)
  -- apart-fresh aprt (TAFailedCast wt x₁ x₂ x₃) = FFailedCast (apart-fresh aprt wt)


----- working on freshness in weakening; some promising but i think wrong
    -- older versions below
    -- weaken-synth : ∀{ x Γ e τ τ'} → x # Γ → Γ ⊢ e => τ → (Γ ,, (x , τ')) ⊢ e => τ
    -- weaken-synth apt SConst = SConst
    -- weaken-synth apt (SAsc x₁) = SAsc (weaken-ana apt x₁)
    -- weaken-synth {x = y} {Γ = Γ} apt (SVar {τ = τ} {x = x} x₁) = SVar (x∈∪l Γ (■ (y , _)) x τ x₁)
    -- weaken-synth apt (SAp x₁ wt x₂ x₃) = SAp x₁ (weaken-synth apt wt) x₂ (weaken-ana apt x₃)
    -- weaken-synth apt SEHole = SEHole
    -- weaken-synth apt (SNEHole x₁ wt) = SNEHole x₁ (weaken-synth apt wt)
    -- weaken-synth {x = y} {Γ = Γ} apt (SLam {x = x} x₂ wt) with natEQ x y
    -- weaken-synth {x = y} {Γ = Γ} apt (SLam x₃ wt) | Inl refl = {!!}
    -- weaken-synth {x = y} {Γ = Γ} apt (SLam {x = x} x₃ wt) | Inr x₂ =
    --              SLam (apart-parts Γ (■ (y , _)) x x₃ (apart-singleton x₂))
    --                   (exchange-synth {Γ = Γ} x₂ (weaken-synth (apart-parts Γ (■ (x , _)) y apt (apart-singleton (flip x₂))) wt))

    -- weaken-ana : ∀{x Γ e τ τ'} → x # Γ → Γ ⊢ e <= τ → (Γ ,, (x , τ')) ⊢ e <= τ
    -- weaken-ana apt (ASubsume x₁ x₂) = ASubsume (weaken-synth {!!} x₁) x₂
    -- weaken-ana {x = y} {Γ = Γ} apt (ALam {x = x} x₂ x₃ wt) with natEQ x y
    -- weaken-ana apt (ALam x₃ x₄ wt) | Inl refl = {!!}
    -- weaken-ana {x = y} {Γ = Γ} apt (ALam {x = x} x₃ x₄ wt) | Inr x₂ =
    --              ALam (apart-parts Γ (■ (y , _)) x x₃ (apart-singleton x₂)) x₄
    --                   (exchange-ana {Γ = Γ} x₂ (weaken-ana (apart-parts Γ (■ (x , _)) y apt (apart-singleton (flip x₂))) wt))


-----

scraps from subst lemma

-- apart-union1 Γ (■ (x , _)) y x₂ | apart-noteq y x _ (apart-union2 Γ (■ (x , _)) y x₂)

  -- lem-subst {Γ = Γ} {x = x} apt (TALam  {x = y} x₂ wt1) wt2 -- = {!weaken-ta ? (TALam x₂ wt1)!}
  --   with natEQ y x
  -- lem-subst {Γ = Γ} {x = x} apt (TALam x₃ wt1) wt2 | Inl refl = abort ((π1(lem-union-none {Γ = Γ} x₃)) refl)
  -- lem-subst {Γ = Γ} apt (TALam x₃ wt1) wt2 | Inr x₂
  --   with lem-union-none {Γ = Γ} x₃ -- | lem-subst apt wt1  -- probably not the straight IH; need to weaken
  -- ... | neq , r = {!!}
  -- --  TALam r (lem-subst {!!} (weaken-ta {!!} {!!}) (weaken-ta r wt2))

  -- context pretty printer is going ape; i know that wt1 has type
  --
  --   (.Δ , Γ ,, (x , .τ1) ,, (y , .τ2) ⊢ .d :: .τ3)
  --
  -- because exchange-ta-Γ {Γ = Γ} x≠y wt1 has type
  --
  --   .Δ , Γ ,, (y , .τ2) ,, (x , .τ1) ⊢ .d :: .τ3

--   ... | Inr _ = TALam y#Γ {!lem-subst {Δ = Δ} {Γ = Γ ,, (y , τ1)} {x = x} {d1 = d}  !}

-----

i don't think the last statement in cast-inert.agda is actually true. in
the case for lambdas, if both multi-steps are reflexive (i.e. you're done
stepping) you get down to

Goal: (·λ .x [ .τ ] .d) == (·λ .x [ .τ ] .d')
————————————————————————————————————————————————————————————
nic : no-id-casts .d .d'
wt  : .Δ , .Γ ,, (.x , .τ) ⊢ .d :: .τ2
x₁  : .Γ .x == None

which isn't true. if d is (c < b => b >) then d' is (c) and the goal is
false.

----------------

these are actually false! exactly because of the hole case. removing them
and trying to prove what they depended on syntactically rather than via weakening


  --todo move to weakening when done
  -- weaken-hole-synth : ∀{Γ x τ' u} → x # Γ → (Γ ,, (x , τ')) ⊢ ⦇⦈[ u ] ⇒ ⦇⦈ ~> ⦇⦈⟨ u , Id Γ ⟩ ⊣  ■ (u , (Γ , ⦇⦈))
  -- weaken-hole-synth apt = {!!}

  -- ex : ∀{Γ x τ' u} → x # Γ → (Γ ,, (x , τ')) ⊢ ⦇⦈[ u ] ⇒ ⦇⦈ ~> ⦇⦈⟨ u , Id (Γ ,, (x , τ')) ⟩ ⊣  ■ (u , ((Γ ,, (x , τ')) , ⦇⦈))
  -- ex = λ {Γ} {x} {τ'} {u} _ → ESEHole

  -- mutual
  --   weaken-synth-expand : ∀{x Γ e τ d Δ τ'} → fresh x d
  --                                            → Γ ⊢ e ⇒ τ ~> d ⊣ Δ
  --                                            → (Γ ,, (x , τ')) ⊢ e ⇒ τ ~> d ⊣ Δ
  --   weaken-synth-expand frsh ESConst = ESConst
  --   weaken-synth-expand {x = y} {Γ = Γ} {τ = τ} frsh (ESVar {x = x} x₂) = ESVar (x∈∪l Γ (■ (y , _)) x τ x₂)
  --   weaken-synth-expand {Γ = Γ} (FLam x₁ frsh) (ESLam x₂ syn) = ESLam (apart-extend1 Γ (flip x₁) x₂) (exchange-expand-synth {Γ = Γ} (flip x₁) (weaken-synth-expand frsh syn))
  --   weaken-synth-expand (FAp (FCast frsh) (FCast frsh₁)) (ESAp x₁ x₂ x₃ x₄ x₅ x₆) = ESAp x₁ x₂ (weaken-synth (fresh-expand-ana2 frsh x₅) x₃) x₄ (weaken-ana-expand frsh x₅) (weaken-ana-expand frsh₁ x₆)
  --   weaken-synth-expand (FHole (EFId x₁)) ESEHole = {!!}
  --   weaken-synth-expand frsh (ESNEHole x₁ syn) = {!!}
  --   weaken-synth-expand (FCast frsh) (ESAsc x₁) = ESAsc (weaken-ana-expand frsh x₁)

  --   weaken-ana-expand : ∀{ Γ e τ d τ' Δ x τ* } → fresh x d
  --                                               → Γ ⊢ e ⇐ τ ~> d :: τ' ⊣ Δ
  --                                               → (Γ ,, (x , τ*)) ⊢ e ⇐ τ ~> d :: τ' ⊣ Δ
  --   weaken-ana-expand {Γ = Γ} (FLam x₁ frsh) (EALam x₂ x₃ ana) = EALam (apart-extend1 Γ (flip x₁) x₂) x₃ (exchange-expand-ana {Γ = Γ} (flip x₁) (weaken-ana-expand frsh ana))
  --   weaken-ana-expand frsh (EASubsume x₁ x₂ x₃ x₄) = EASubsume x₁ x₂ (weaken-synth-expand frsh x₃) x₄
  --   weaken-ana-expand (FHole (EFId x₁)) EAEHole = {!!}
  --   weaken-ana-expand (FNEHole (EFId x₁) frsh) (EANEHole x₂ x₃) = {!!}

    -- expand-ana-disjoint hd (EASubsume x x₁ x₂ x₃) E2 = expand-synth-disjoint hd x₂ E2
    -- expand-ana-disjoint (HDLam1 hd) (EALam x₁ x₂ E1) E2 = {!!}
    -- --expand-ana-disjoint (HDLam1 hd) (EASubsume x₁ x₂ x₃ x₄) E2 = ?
    -- -- expand-ana-disjoint hd ex1 {!!} -- (weaken-ana-expand {!fresh-expand-ana1 x₁ (expand-fresh-ana x₁ E2) E2!} E2)
    -- expand-ana-disjoint (HDHole x) EAEHole E2 = ##-comm (expand-new-disjoint-ana x E2)
    -- expand-ana-disjoint (HDNEHole x hd) (EANEHole x₁ x₂) E2 = disjoint-parts (expand-synth-disjoint hd x₂ E2) (##-comm (expand-new-disjoint-ana x E2))

    -- expand-synth-disjoint : ∀{ e1 e2 τ1 τ2 e1' e2' τ2' Γ Δ1 Δ2 } →
    --       holes-disjoint e1 e2 →
    --       Γ ⊢ e1 ⇒ τ1 ~> e1' ⊣ Δ1 →
    --       Γ ⊢ e2 ⇐ τ2 ~> e2' :: τ2' ⊣ Δ2 →
    --       Δ1 ## Δ2
    -- expand-synth-disjoint HDConst ESConst ana = empty-disj _
    -- expand-synth-disjoint (HDAsc hd) (ESAsc x) ana = expand-ana-disjoint hd x ana
    -- expand-synth-disjoint HDVar (ESVar x₁) ana = empty-disj _
    -- expand-synth-disjoint (HDLam1 hd) () ana
    -- expand-synth-disjoint (HDLam2 hd) (ESLam x₁ synth) ana = {!!} --  expand-synth-disjoint hd synth {!!} -- (weaken-ana-expand {!!} ana)
    -- expand-synth-disjoint (HDHole x) ESEHole ana = ##-comm (expand-new-disjoint-ana x ana)
    -- expand-synth-disjoint (HDNEHole x hd) (ESNEHole x₁ synth) ana = disjoint-parts (expand-synth-disjoint hd synth ana) (##-comm (expand-new-disjoint-ana x ana))
    -- expand-synth-disjoint (HDAp hd hd₁) (ESAp x x₁ x₂ x₃ x₄ x₅) ana = disjoint-parts (expand-ana-disjoint hd x₄ ana) (expand-ana-disjoint hd₁ x₅ ana)
